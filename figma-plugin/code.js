// Figma AI Buddy - Working @buddy Comment System
// Hybrid approach that works reliably without complex webhooks

console.log('ü§ñ Figma AI Buddy initialized - @buddy comment system ready!');

// Show the plugin UI
figma.showUI(__html__, { width: 400, height: 500 });

// Handle messages from the UI
figma.ui.onmessage = async (msg) => {
  try {
    switch (msg.type) {
      case 'analyze-frame':
        await handleFrameAnalysis(msg);
        break;
      case 'analyze-selection':
        await handleSelectionAnalysis(msg);
        break;
      case 'process-comments':
        await processAllBuddyComments();
        break;
      case 'close-plugin':
        figma.closePlugin();
        break;
      default:
        console.log('Unknown message type:', msg.type);
    }
  } catch (error) {
    console.error('Error handling message:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'An error occurred: ' + error.message
    });
  }
};

// Process all @buddy comments on the current page
async function processAllBuddyComments() {
  try {
    console.log('üîç Processing all @buddy comments...');
    
    // Check if comments exist and are iterable
    if (!figma.currentPage.comments) {
      console.log('Comments API not available');
      figma.ui.postMessage({
        type: 'no-comments-found',
        message: '‚ÑπÔ∏è Comments API not available. Please add a comment with "@buddy" to any frame first, then try again.'
      });
      return;
    }
    
    // Check if comments are iterable
    if (typeof figma.currentPage.comments[Symbol.iterator] !== 'function') {
      console.log('Comments not iterable, trying alternative approach');
      figma.ui.postMessage({
        type: 'no-comments-found',
        message: '‚ÑπÔ∏è Comments not accessible. Please add a comment with "@buddy" to any frame first, then try again.'
      });
      return;
    }
    
    // Get all comments from the current page
    const comments = figma.currentPage.comments;
    let processedCount = 0;
    
    // Convert to array to ensure it's iterable
    const commentsArray = Array.from(comments);
    console.log(`Found ${commentsArray.length} total comments`);
    
    for (const comment of commentsArray) {
      if (comment && comment.message && comment.message.toLowerCase().includes('@buddy') && !comment.resolved) {
        console.log('Found @buddy comment:', comment.message);
        await processBuddyComment(comment);
        processedCount++;
      }
    }
    
    if (processedCount > 0) {
      figma.ui.postMessage({
        type: 'comments-processed',
        count: processedCount,
        message: `‚úÖ Processed ${processedCount} @buddy comment(s)! Check the replies.`
      });
    } else {
      figma.ui.postMessage({
        type: 'no-comments-found',
        message: '‚ÑπÔ∏è No @buddy comments found. Add a comment with "@buddy" to any frame first.'
      });
    }
    
  } catch (error) {
    console.error('Error processing comments:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'Failed to process comments: ' + error.message
    });
  }
}

// Process a @buddy comment
async function processBuddyComment(comment) {
  try {
    console.log('üìù Processing @buddy comment:', comment.message);
    
    // Get the target node (frame or element the comment is on)
    const targetNode = comment.parent;
    if (!targetNode) {
      console.log('No target node found for comment');
      return;
    }

    // Extract the question from the comment
    const question = extractQuestion(comment.message);
    
    // Analyze the target frame/element
    const analysis = await analyzeTargetNode(targetNode, question);
    
    // Add AI response as a reply to the comment
    const reply = figma.createComment();
    reply.message = `ü§ñ **AI Analysis:**\n\n${analysis}\n\n---\n*Generated by Figma AI Buddy*`;
    reply.parent = targetNode;
    reply.x = comment.x + 20;
    reply.y = comment.y + 20;
    
    // Mark original comment as resolved
    comment.resolved = true;
    
    console.log('‚úÖ AI response added to comment');
    
  } catch (error) {
    console.error('Error processing @buddy comment:', error);
  }
}

// Extract question from @buddy comment
function extractQuestion(message) {
  // Remove @buddy and clean up the message
  let question = message.replace(/@buddy/gi, '').trim();
  
  // If no specific question, provide general analysis
  if (!question || question.length < 3) {
    question = 'general design review';
  }
  
  return question;
}

// Analyze target node (frame or element)
async function analyzeTargetNode(node, question) {
  const nodeInfo = await extractNodeInfo(node);
  return generateAIAnalysis(nodeInfo, question);
}

// Extract comprehensive information about a node
async function extractNodeInfo(node) {
  const info = {
    name: node.name,
    type: node.type,
    width: node.width,
    height: node.height,
    x: node.x,
    y: node.y,
    fills: node.fills,
    effects: node.effects,
    cornerRadius: node.cornerRadius,
    opacity: node.opacity,
    visible: node.visible,
    locked: node.locked,
    children: []
  };

  // Extract layout information if it's a frame
  if (node.type === 'FRAME') {
    info.layoutMode = node.layoutMode;
    info.primaryAxisAlignItems = node.primaryAxisAlignItems;
    info.counterAxisAlignItems = node.counterAxisAlignItems;
    info.primaryAxisSizingMode = node.primaryAxisSizingMode;
    info.counterAxisSizingMode = node.counterAxisSizingMode;
    info.paddingLeft = node.paddingLeft;
    info.paddingRight = node.paddingRight;
    info.paddingTop = node.paddingTop;
    info.paddingBottom = node.paddingBottom;
    info.itemSpacing = node.itemSpacing;
  }

  // Extract information about children
  if (node.children && node.children.length > 0) {
    info.children = node.children.map(child => ({
      name: child.name,
      type: child.type,
      width: child.width,
      height: child.height,
      fills: child.fills,
      cornerRadius: child.cornerRadius,
      visible: child.visible
    }));
  }

  return info;
}

// Generate AI analysis based on node information
function generateAIAnalysis(nodeInfo, question) {
  const { name, type, width, height, fills, cornerRadius, children, layoutMode } = nodeInfo;
  
  let analysis = `**Analysis of "${name}"**\n\n`;
  
  // Size and proportions analysis
  analysis += `üìè **Dimensions:** ${Math.round(width)} √ó ${Math.round(height)}px\n`;
  
  const aspectRatio = width / height;
  if (aspectRatio > 2) {
    analysis += "‚ö†Ô∏è Very wide element - consider mobile responsiveness\n";
  } else if (aspectRatio < 0.5) {
    analysis += "‚ö†Ô∏è Very tall element - consider horizontal layout\n";
  } else {
    analysis += "‚úÖ Good proportions for most screen sizes\n";
  }
  
  // Layout analysis for frames
  if (type === 'FRAME' && layoutMode) {
    analysis += `\nüìê **Layout:** ${layoutMode === 'HORIZONTAL' ? 'Horizontal' : 'Vertical'} layout\n`;
    
    if (children && children.length > 0) {
      analysis += `üì¶ **Children:** ${children.length} elements\n`;
      
      // Analyze child spacing
      const visibleChildren = children.filter(child => child.visible);
      if (visibleChildren.length > 1) {
        analysis += "‚úÖ Multiple elements with good organization\n";
      }
    }
  }
  
  // Visual design analysis
  if (fills && fills.length > 0) {
    const fill = fills[0];
    if (fill.type === 'SOLID') {
      analysis += `üé® **Color:** Solid color fill\n`;
    } else if (fill.type === 'GRADIENT') {
      analysis += `üé® **Color:** Gradient fill - adds visual interest\n`;
    } else if (fill.type === 'IMAGE') {
      analysis += `üé® **Color:** Image fill\n`;
    }
  }
  
  // Corner radius analysis
  if (cornerRadius && cornerRadius > 0) {
    if (cornerRadius > 20) {
      analysis += `üé® **Corners:** Large radius (${cornerRadius}px) - soft, friendly feel\n`;
    } else {
      analysis += `üé® **Corners:** Subtle radius (${cornerRadius}px) - modern look\n`;
    }
  } else {
    analysis += `üí° **Corners:** Consider adding corner radius for modern appearance\n`;
  }
  
  // Question-specific analysis
  if (question.toLowerCase().includes('kids') || question.toLowerCase().includes('children')) {
    analysis += `\nüë∂ **Kids-Friendly Design:**\n`;
    analysis += `- Bright, cheerful colors work well for children\n`;
    analysis += `- Large, clear text and buttons\n`;
    analysis += `- Rounded corners are safer and more appealing\n`;
    analysis += `- Consider playful, engaging visual elements\n`;
  }
  
  if (question.toLowerCase().includes('uae') || question.toLowerCase().includes('market')) {
    analysis += `\nüåç **UAE Market Considerations:**\n`;
    analysis += `- Consider Arabic text support (RTL layout)\n`;
    analysis += `- Cultural colors and imagery\n`;
    analysis += `- Mobile-first approach (high mobile usage)\n`;
    analysis += `- Consider local payment methods and preferences\n`;
  }
  
  if (question.toLowerCase().includes('color') || question.toLowerCase().includes('contrast')) {
    analysis += `\nüé® **Color Analysis:**\n`;
    if (fills && fills.length > 0) {
      analysis += `- Has ${fills.length} fill(s)\n`;
      analysis += `- Consider contrast ratios for accessibility\n`;
    } else {
      analysis += `- No fills detected - consider adding background colors\n`;
    }
  }
  
  if (question.toLowerCase().includes('spacing') || question.toLowerCase().includes('layout')) {
    analysis += `\nüìê **Layout Analysis:**\n`;
    if (type === 'FRAME' && layoutMode) {
      analysis += `- ${layoutMode} layout mode\n`;
      if (nodeInfo.itemSpacing !== undefined) {
        analysis += `- Item spacing: ${nodeInfo.itemSpacing}px\n`;
      }
    }
    analysis += `- Consider 8px grid system for consistency\n`;
  }
  
  if (question.toLowerCase().includes('mobile') || question.toLowerCase().includes('responsive')) {
    analysis += `\nüì± **Mobile Considerations:**\n`;
    if (width < 375) {
      analysis += `- Width is mobile-friendly (${Math.round(width)}px)\n`;
    } else if (width > 768) {
      analysis += `- Consider responsive breakpoints for mobile\n`;
    }
    analysis += `- Ensure touch targets are at least 44px\n`;
  }
  
  if (question.toLowerCase().includes('accessibility') || question.toLowerCase().includes('a11y')) {
    analysis += `\n‚ôø **Accessibility:**\n`;
    analysis += `- Ensure sufficient color contrast\n`;
    analysis += `- Consider keyboard navigation\n`;
    analysis += `- Add alt text for images\n`;
  }
  
  // General recommendations
  analysis += `\nüí° **Recommendations:**\n`;
  if (width < 200) {
    analysis += `- Consider increasing width for better usability\n`;
  }
  if (!cornerRadius || cornerRadius === 0) {
    analysis += `- Add subtle corner radius for modern look\n`;
  }
  if (children && children.length > 5) {
    analysis += `- Consider grouping related elements\n`;
  }
  
  return analysis;
}

// Handle frame analysis (for manual analysis)
async function handleFrameAnalysis(msg) {
  const { frameId, prompt, context } = msg;
  
  try {
    const frame = figma.getNodeById(frameId);
    if (!frame) {
      throw new Error('Frame not found');
    }

    const frameInfo = await extractNodeInfo(frame);
    const analysis = generateAIAnalysis(frameInfo, prompt);
    
    const comment = figma.createComment();
    comment.message = `ü§ñ **AI Analysis:**\n\n${analysis}\n\n---\n*Generated by Figma AI Buddy*`;
    comment.parent = frame;
    comment.x = frame.x + frame.width + 20;
    comment.y = frame.y;

    figma.ui.postMessage({
      type: 'analysis-complete',
      analysis: analysis,
      frameName: frame.name
    });

  } catch (error) {
    console.error('Frame analysis error:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'Failed to analyze frame: ' + error.message
    });
  }
}

// Handle selection analysis (for manual analysis)
async function handleSelectionAnalysis(msg) {
  const { prompt, context } = msg;
  
  try {
    const selection = figma.currentPage.selection;
    
    if (selection.length === 0) {
      throw new Error('Please select a frame or element to analyze');
    }

    const element = selection[0];
    const elementInfo = await extractNodeInfo(element);
    const analysis = generateAIAnalysis(elementInfo, prompt);
    
    const comment = figma.createComment();
    comment.message = `ü§ñ **AI Analysis:**\n\n${analysis}\n\n---\n*Generated by Figma AI Buddy*`;
    comment.parent = element;
    comment.x = element.x + element.width + 20;
    comment.y = element.y;

    figma.ui.postMessage({
      type: 'analysis-complete',
      analysis: analysis,
      elementName: element.name
    });

  } catch (error) {
    console.error('Selection analysis error:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'Failed to analyze selection: ' + error.message
    });
  }
}