// Figma AI Buddy - Real-time @buddy Comment System
// World-class solution with webhook integration and minimal latency

console.log('ü§ñ Figma AI Buddy initialized - Real-time @buddy system ready!');

// Show the plugin UI
figma.showUI(__html__, { width: 400, height: 500 });

// Handle messages from the UI
figma.ui.onmessage = async (msg) => {
  try {
    switch (msg.type) {
      case 'setup-webhook':
        await setupWebhook();
        break;
      case 'check-webhook':
        await checkWebhookStatus();
        break;
      case 'analyze-selection':
        await handleSelectionAnalysis(msg);
        break;
      case 'close-plugin':
        figma.closePlugin();
        break;
      default:
        console.log('Unknown message type:', msg.type);
    }
  } catch (error) {
    console.error('Error handling message:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'An error occurred: ' + error.message
    });
  }
};

// Setup webhook for real-time @buddy comments
async function setupWebhook() {
  try {
    console.log('üîó Setting up webhook for real-time @buddy comments...');
    
    // Get current user info
    const user = figma.currentUser;
    if (!user) {
      throw new Error('User not authenticated');
    }

    // Send webhook setup request to backend
    const response = await fetch('https://buddy-lac-five.vercel.app/api/user?action=create-webhook', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        figmaUserId: user.id,
        figmaUserName: user.name,
        figmaUserEmail: user.email,
        fileKey: figma.fileKey,
        webhookUrl: 'https://buddy-lac-five.vercel.app/api/figma-comment-webhook'
      })
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(`Webhook setup failed: ${error}`);
    }

    const result = await response.json();
    
    figma.ui.postMessage({
      type: 'webhook-setup-success',
      webhookId: result.webhookId,
      message: 'Webhook setup complete! @buddy comments will now work in real-time.'
    });

    console.log('‚úÖ Webhook setup successful');

  } catch (error) {
    console.error('Webhook setup error:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'Failed to setup webhook: ' + error.message
    });
  }
}

// Check webhook status
async function checkWebhookStatus() {
  try {
    const user = figma.currentUser;
    if (!user) {
      throw new Error('User not authenticated');
    }

    const response = await fetch(`https://buddy-lac-five.vercel.app/api/user?action=webhooks&figmaUserId=${user.id}`);
    
    if (!response.ok) {
      throw new Error('Failed to check webhook status');
    }

    const result = await response.json();
    
    figma.ui.postMessage({
      type: 'webhook-status',
      hasWebhook: result.webhooks && result.webhooks.length > 0,
      webhooks: result.webhooks || []
    });

  } catch (error) {
    console.error('Webhook status check error:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'Failed to check webhook status: ' + error.message
    });
  }
}

// Handle selection analysis (for manual testing)
async function handleSelectionAnalysis(msg) {
  const { prompt, context } = msg;
  
  try {
    const selection = figma.currentPage.selection;
    
    if (selection.length === 0) {
      throw new Error('Please select a frame or element to analyze');
    }

    const element = selection[0];
    const elementInfo = await extractNodeInfo(element);
    const analysis = generateAIAnalysis(elementInfo, prompt);
    
    const comment = figma.createComment();
    comment.message = `ü§ñ **AI Analysis:**\n\n${analysis}\n\n---\n*Generated by Figma AI Buddy*`;
    comment.parent = element;
    comment.x = element.x + element.width + 20;
    comment.y = element.y;

    figma.ui.postMessage({
      type: 'analysis-complete',
      analysis: analysis,
      elementName: element.name
    });

  } catch (error) {
    console.error('Selection analysis error:', error);
    figma.ui.postMessage({
      type: 'error',
      message: 'Failed to analyze selection: ' + error.message
    });
  }
}

// Extract comprehensive information about a node
async function extractNodeInfo(node) {
  const info = {
    name: node.name,
    type: node.type,
    width: node.width,
    height: node.height,
    x: node.x,
    y: node.y,
    fills: node.fills,
    effects: node.effects,
    cornerRadius: node.cornerRadius,
    opacity: node.opacity,
    visible: node.visible,
    locked: node.locked,
    children: []
  };

  // Extract layout information if it's a frame
  if (node.type === 'FRAME') {
    info.layoutMode = node.layoutMode;
    info.primaryAxisAlignItems = node.primaryAxisAlignItems;
    info.counterAxisAlignItems = node.counterAxisAlignItems;
    info.primaryAxisSizingMode = node.primaryAxisSizingMode;
    info.counterAxisSizingMode = node.counterAxisSizingMode;
    info.paddingLeft = node.paddingLeft;
    info.paddingRight = node.paddingRight;
    info.paddingTop = node.paddingTop;
    info.paddingBottom = node.paddingBottom;
    info.itemSpacing = node.itemSpacing;
  }

  // Extract information about children
  if (node.children && node.children.length > 0) {
    info.children = node.children.map(child => ({
      name: child.name,
      type: child.type,
      width: child.width,
      height: child.height,
      fills: child.fills,
      cornerRadius: child.cornerRadius,
      visible: child.visible
    }));
  }

  return info;
}

// Generate AI analysis based on node information
function generateAIAnalysis(nodeInfo, question) {
  const { name, type, width, height, fills, cornerRadius, children, layoutMode } = nodeInfo;
  
  let analysis = `**Analysis of "${name}"**\n\n`;
  
  // Size and proportions analysis
  analysis += `üìè **Dimensions:** ${Math.round(width)} √ó ${Math.round(height)}px\n`;
  
  const aspectRatio = width / height;
  if (aspectRatio > 2) {
    analysis += "‚ö†Ô∏è Very wide element - consider mobile responsiveness\n";
  } else if (aspectRatio < 0.5) {
    analysis += "‚ö†Ô∏è Very tall element - consider horizontal layout\n";
  } else {
    analysis += "‚úÖ Good proportions for most screen sizes\n";
  }
  
  // Layout analysis for frames
  if (type === 'FRAME' && layoutMode) {
    analysis += `\nüìê **Layout:** ${layoutMode === 'HORIZONTAL' ? 'Horizontal' : 'Vertical'} layout\n`;
    
    if (children && children.length > 0) {
      analysis += `üì¶ **Children:** ${children.length} elements\n`;
      
      // Analyze child spacing
      const visibleChildren = children.filter(child => child.visible);
      if (visibleChildren.length > 1) {
        analysis += "‚úÖ Multiple elements with good organization\n";
      }
    }
  }
  
  // Visual design analysis
  if (fills && fills.length > 0) {
    const fill = fills[0];
    if (fill.type === 'SOLID') {
      analysis += `üé® **Color:** Solid color fill\n`;
    } else if (fill.type === 'GRADIENT') {
      analysis += `üé® **Color:** Gradient fill - adds visual interest\n`;
    } else if (fill.type === 'IMAGE') {
      analysis += `üé® **Color:** Image fill\n`;
    }
  }
  
  // Corner radius analysis
  if (cornerRadius && cornerRadius > 0) {
    if (cornerRadius > 20) {
      analysis += `üé® **Corners:** Large radius (${cornerRadius}px) - soft, friendly feel\n`;
    } else {
      analysis += `üé® **Corners:** Subtle radius (${cornerRadius}px) - modern look\n`;
    }
  } else {
    analysis += `üí° **Corners:** Consider adding corner radius for modern appearance\n`;
  }
  
  // Question-specific analysis
  if (question.toLowerCase().includes('kids') || question.toLowerCase().includes('children')) {
    analysis += `\nüë∂ **Kids-Friendly Design:**\n`;
    analysis += `- Bright, cheerful colors work well for children\n`;
    analysis += `- Large, clear text and buttons\n`;
    analysis += `- Rounded corners are safer and more appealing\n`;
    analysis += `- Consider playful, engaging visual elements\n`;
  }
  
  if (question.toLowerCase().includes('uae') || question.toLowerCase().includes('market')) {
    analysis += `\nüåç **UAE Market Considerations:**\n`;
    analysis += `- Consider Arabic text support (RTL layout)\n`;
    analysis += `- Cultural colors and imagery\n`;
    analysis += `- Mobile-first approach (high mobile usage)\n`;
    analysis += `- Consider local payment methods and preferences\n`;
  }
  
  if (question.toLowerCase().includes('color') || question.toLowerCase().includes('contrast')) {
    analysis += `\nüé® **Color Analysis:**\n`;
    if (fills && fills.length > 0) {
      analysis += `- Has ${fills.length} fill(s)\n`;
      analysis += `- Consider contrast ratios for accessibility\n`;
    } else {
      analysis += `- No fills detected - consider adding background colors\n`;
    }
  }
  
  if (question.toLowerCase().includes('spacing') || question.toLowerCase().includes('layout')) {
    analysis += `\nüìê **Layout Analysis:**\n`;
    if (type === 'FRAME' && layoutMode) {
      analysis += `- ${layoutMode} layout mode\n`;
      if (nodeInfo.itemSpacing !== undefined) {
        analysis += `- Item spacing: ${nodeInfo.itemSpacing}px\n`;
      }
    }
    analysis += `- Consider 8px grid system for consistency\n`;
  }
  
  if (question.toLowerCase().includes('mobile') || question.toLowerCase().includes('responsive')) {
    analysis += `\nüì± **Mobile Considerations:**\n`;
    if (width < 375) {
      analysis += `- Width is mobile-friendly (${Math.round(width)}px)\n`;
    } else if (width > 768) {
      analysis += `- Consider responsive breakpoints for mobile\n`;
    }
    analysis += `- Ensure touch targets are at least 44px\n`;
  }
  
  if (question.toLowerCase().includes('accessibility') || question.toLowerCase().includes('a11y')) {
    analysis += `\n‚ôø **Accessibility:**\n`;
    analysis += `- Ensure sufficient color contrast\n`;
    analysis += `- Consider keyboard navigation\n`;
    analysis += `- Add alt text for images\n`;
  }
  
  // General recommendations
  analysis += `\nüí° **Recommendations:**\n`;
  if (width < 200) {
    analysis += `- Consider increasing width for better usability\n`;
  }
  if (!cornerRadius || cornerRadius === 0) {
    analysis += `- Add subtle corner radius for modern look\n`;
  }
  if (children && children.length > 5) {
    analysis += `- Consider grouping related elements\n`;
  }
  
  return analysis;
}